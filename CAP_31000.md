
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> 
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

### MÉTODO DO RECOZIMENTO SIMULADO
<p align="justify">
<font color="red">LUCAS OBSERVE ABAIXO AS MINHAS CORREÇÕES PARA AUE VOCÊ POSSA FAZER MELHOR NOS PRÓXIMOS TEXTOS. EU TENHO COMO COSTUME SEMPRE CONTAR A HISTÓRIA DO MÉTODO E QUEM O método de recozimento simulado foi desenvolvido na década de 80 pelos autores Kirkpatrick1, Gelatt Jr. e Vecchi<a href="https://science.sciencemag.org/content/220/4598/671">[1]</a>

</p>

Recozimento Simulado, mais conhecido como Simulated Annealing é um método heurístico usado para se obter uma otimização a partir de uma busca local probabilística. Tanto seu nome quanto seu algoritmo são baseados em conceitos da termodinâmica aplicados na metalurgia, onde, para se obter um metal com uma baixa energia se segue o seguinte procedimento:

Primeiro, o metal é aquecido para que se torne mais maleável e seus átomos fiquem agitados. Logo depois, o metal é lentamente resfriado até que o metal volte ao seu estado inicial solido e seus átomos fiquem mais controlados. Esse procedimento serve para corrigir os defeitos do metal.

### PSEUDO-CÓDIGO DO ALGORITMO
Agora, aplicando esse conhecimento de recozimento em forma de algoritmo temos o seguinte pseudo-código:
 
Explicação das variáveis:
  •	$$ T $$ → Temperatura Inicial (Definido pelo usuário).    
  •	$$ NMI $$ → Número máximo de iterações (Definido pelo usuário).
  •	$$ P $$ → Ponto inicial aleatório.
  •	$$ NAI $$ → Número atual de iterações.
  •	$$ PN $$ → Ponto Novo.
  •	$$ PA $$ → Ponto anterior.
  •	$$ FoPN $$ → Função objetivo do ponto novo.
  •	$$ FoPA $$ → Função objetivo do ponto anterior.
  •	$$ ΔFo $$ → Diferença entre as funções objetivo.
  •	$$ Ti $$ → Temperatura na iteração.

Além dessas variáveis também existem as seguintes funções:
  •	$$ Pertuba(Ponto) $$ → Função que pertuba um ponto e retorna um novo ponto.
  •	$$ FO(Ponto) $$ → Função que retorna a função objetivo no Ponto.
  •	$$ Prob() $$ → Retorna um decimal entre 0 e 1.

``` python
  RecozimentoSimulado:
    # Inicializa algumas variáveis:
    NAI = 0
    PA = P
    
    # Começa o loop principal.
    Enquanto NAI < NMI:
      NAI = NAI + 1
      Ti = T / NAI      # Descobre a temperatura nessa iteração
      PN = Pertuba(PA)  # Pertuba o ponto para descobrir um novo.
      
      # Descobre as Funções Objetivo desses pontos e sua diferença.
      FoPA = FO(PA)
      FoPN = FO(PN)
      ΔFo = FoPN - foPA
      
      # Condição para decidir se vale ou não a pena usar esse novo ponto
      Se ( ΔFo < 0 ) ou ( exp(-ΔFo/Ti) > Prob() ) então:
        FoPA = FoPN
        
    Retorna FoPA  # Melhor ponto 
```
### EXPLICAÇÃO DO ALGORITMO
Recozimento Simulado pode ser comparado com um outro algoritmo chamado Subida de Encosta (Hill Climbing), neste um ponto verifica seu vizinho e sempre vai para a onde há um melhor resultado, porém, apenas essa verificação faz com que o ponto sempre fique preso em um máximo local e não consiga encontrar o máximo global. Já o Recozimento Simulado tem um mecanismo probabilístico que o permite ir para lugares que dão um resultado ruim caso isso permita que ele saia de um máximo local e alcance o global.

Esse mecanismo é a temperatura. No início ela está alta, dando uma maior chance de aceitar um resultado ruim, entretanto, conforme cada iteração, essa temperatura vai diminuindo fazendo com que essa probabilidade de aceitação diminua. Logo, podemos afirmar que a probabilidade de aceitação de um resultado ruim é diretamente proporcional à temperatura.

Com isso, o problema encontrado no algoritmo da Subida de Encosta é solucionado, alguns problemas podem ser encontrados para a utilização do algoritmo como: Saber com qual temperatura iniciar, não há como saber se uma temperatura irá atender ou não o problema até testar, por isso, um dos métodos recomendados é testar vários valores diferentes até achar um com uma boa taxa e acerto.

### EXEMPLOS DE PROBLEMAS RESOLVÍVEIS
  •	Problema do Caixeiro Viajante;  
  •	Problema de Alocação;  
  •	Problema de Agendamento.
  
### MÉTODO DO ENXAME DE PARTÍCULAS

<p align="justify">
O método de Enxame de Partículas (em inglês <i>Particle Swarm Optimizatio</i>-PSO) foi proposto por James Kennedy e Russell Elberthart em 1995 [<font color="red">EULLER AQUI VOCÊ TEM QUE JÁ CITAR O ARTIGO DO PSO O ORIGINAL COLOQUE COMO URL O LINK DO ARTIGO VOU TE DAR UM EXEMPLO VEJA A FRENTE</font>] <a href="https://arxiv.org/ftp/arxiv/papers/1804/1804.05319.pdf">[1]</a>. O Enxame de Partículas ou <b>PSO</b> é um algoritmo metaheurístico baseado em inteligência de enxames que busca simular o comportamento de pássaros e cardume de peixes em busca de alimentos, cada um desses animais são chamados de partícula no método computacional. A particula possue duas propriedades principais que são: (a) a sua posição (\(x_{i}\)); e (b) sua velocidade (\(v_{i}\)), ambas representadas vetorialmente em um espaço \(n\)-dimensional [Iraj Koohi e Voicu Z. Groza <font color="red">EULLER AQUI TROCAR O NOME INTEIRO DOS CARAS POR NÚMERO....ENTÃO NOSSAS REFERÊNCIAS DEVEM SER TODAS NUMÉRICAS 1 2 3 4 5 E ASSIM POR DIANTE COMO FOI NO RELATÓRIO DE IC</font>]. Além disso o método possui uma espécie de memória que armazena um histórico das melhores posições (em relação à aptidão) no espaço \(n\)-dimensional. O histórico de armazenamento relativo a cada partícula é denominado de \( pb \) (em inglês <i>personal best</i>) e o melhor individuo do enxame também terá sua posição armazenada sendo chamado de \( gb \) (em inglês <i>global best</i>). A posição (\(x_{i}\)) e a velocidade (\(v_{i}\)) são modificadas com base nas equações (1) e (2).
</p>

<p align="justify">

\( v_{i}^{t+1} = w . v_{i}^{t} + c_1 . r_1 . (pb_{i}^{t} - x_{i}^{t}) + c_2 . r_2 . (gb_{i}^{t} - x_{i}^{t}) \) <br>  

\( x_{ij}^{t+1} = x_{ij}^{t} + v_{ij} \) <br>

Onde:<br>
</p>

<ul>
<li>\( v_{i}^{t} \) é a velocidade da partícula \(i\) na iteração \(t\).</li>
<li>\( x_{i}^{t} \) é a posição da partícula \(i\) na iteração \(t\).</li>
<li>\( x_{i}^{t+1} \) é a posição da partícula \(i\) na iteração \(t+1\).</li>
<li>\( w \) é o coeficiente de inércia. Vale 1 para versão do algoritmo original.</li>
<li>\( c_1 \) é o fator de aprendizado cognitivo.</li>
<li>\( c_2 \) é o fator de aprendizadp social.</li>
<li>\( r_1 \) e \( r_2 \) são números aleatórios em entre 0 e 1.</li>
</ul>

<p align="justify">
Os fatores de aprendizagem cognitivos e social foram criados para estebalecer um balanço (em inglês <i>trade off</i> no ato da partícula caminhar pelo espaço de busca procurando a melhor solução. Kennedy e Elberthart [1<font color="red">EULLER LEMBRAR DE COLOCAR O HYPERLINK DESSE TEXTO</font>] afirmam que esses coeficientes podem variar de 0 até 4 e quando somados (\( c_1 + c_2\)) a recomendação é que totalizem o valor 4. Além desse balanço na escolha do fator \( c_1 \) e \( c_2 \) a velocidade deve ser fixada em uma faixa, semelhante as restrições laterais (\(x_{min}\) e \(x_{max}\)) nas variáveis de projeto \(x\). Tal fato de criar imposições laterais no vetor de velocidades contribui na estabilidade do método de otimização.<br>

O funcionamento do algoritmo PSO está logo abaixo:
</p>

```python
# Algoritmo em linguagem Python 3
# Declaração de dados iniciais pelo usuário
C1, C2, W, X_MIN, X_MAX, V_MIN, V_MAX
X = POP_INIT(X_MIN, X_MAX)
V = VEL_INIT(V_MIN, V_MAX)
# Avalia FO e FIT das partículas
OF = OBJ(X)
FIT = FITNESS(OF)
for I_COUNT in range(N_ITER)
    # Busca pelos valores pb e gb
    PB = PB_AVALIACAO(X, FIT)
    GB = PB_AVALIACAO(X, FIT)
    for J_COUNT in range(N_POP)
        # Atualização velocidade
        V_NEW = VELOCITY(PB, GB, X, V) 
        # Verificação de limites de velocidade
        V_NEW = LIM_VELOCITY(V_NEW, V_MIN, V_MAX)
        # Atualização da posição no espaço
        X_NEW = POSITION(X, V_NEW)
        # Verificação da posição no espaço
        X_NEW = LIM_POSITION(X_NEW, X_MIN, X_MAX)
        OF_NEW = OBJ(X_NEW)
        FIT = FITNESS(OF_NEW)
        X = X_NEW
        OF = OF_NEW
        FIT = OF_NEW
```
<p align="justify">
  Para ter acesso ao algoritmo pode clicar no <i>link</i> <a href="https://arxiv.org/ftp/arxiv/papers/1804/1804.05319.pdf">PSO AQUI VAMOS COLOCAR O ACESSO AO NOTEBOOK JUPYTER ONLINE</a>
</p>
