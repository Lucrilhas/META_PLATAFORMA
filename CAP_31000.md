
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> 
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

### MÉTODO DO RECOZIMENTO SIMULADO
<font color="red">
LUCAS VOCÊ CONSEGUIU DESENVOLVER BEM SUA ESCRITA PORÉM PRECISAMOS MELHORAR ALGUNS PONTOS. OBSERVE ABAIXO AS MINHAS CORREÇÕES PARA QUE VOCÊ POSSA FAZER MELHOR NOS PRÓXIMOS TEXTOS. 
EU TENHO COMO COSTUME SEMPRE CONTAR A HISTÓRIA DO MÉTODO E QUEM O DESENVOLVE. ISSO É IMPORTANTE MOSTRAR MESMO QUE BREVEMENETE UM CONTEXTO HISTÓRICO VISTO QUE ESSE MATERIAL É EXPLICATIVO. ENTÃO VC VIR CONTANDO DE ONDE O MÉTODO VEIO E QUEM O FEZ É UMA FERRAMENTA DE ESCRITA INTERESSANTE.
 
UMA FALHA DO SEU TEXTO, NA MINHA VISÃO, É A FALTA DE CITAÇÕES. SEMPRE QUANDO FOR FAZER UM TEXTO TÉCNICO/CIENTÍFICO É DE BOM TOM APRESENTAR REFERÊNCIAS. VEJA O PADRÃO QUE FIZ E OBSERVE COMO A LEITURA FICA MAIS FLUIDA POIS VOCÊ CONSEGUE VER OS ARTIGOS QUE CITAM COISAS DO TRABALHO E QUE MOSTRAM APLICAÇÕES DIVERSAS.

VEJA QUE PALAVRAS EM OUTRA LÍNGUA ESTOU COLOCANDO EM INGLÊS...ISSO É PADRÃO UM TEXTO TÉCNICO/CIENTÍFICO CONFORME AS NOSSAS NORMATIVAS DE ESCRITA.

VEJA TBM QUE VÁRIAS PARTES DA SUA ESCRITA FORAM AGREGADOS AO NOVO TEXTO QUE FIZ MELHORANDO AS PALAVRAS E INTRODUZINDOS ALGUNS CONCEITOS DE ENGENHARIA DE MATERIAIS.
 
</font> 
 
<p align="justify"> 
O método de recozimento simulado foi desenvolvido na década de 80 pelos autores Kirkpatrick1, Gelatt Jr. e Vecchi <a href="https://science.sciencemag.org/content/220/4598/671">[1]</a>. Tal método tem como base teórica o processo de fundição de metais. O termo recozimento (em inglês <i>Annealing</i>) é o processo utilizado para fundir um metal, onde este é aquecido a uma temperatura elevada (estado de maior agitação dos átomos) e em seguida é resfriado lentamente, de modo que o produto final seja uma massa homogênea <a href="https://tema.sbmac.org.br/tema/article/view/141">[2]</a>. Na engenharia de materiais o recozimento é conhecido como um tratamento térmico que visa alterar as propriedades da liga metálica conforme o aço que deseja-se produzir. Tal processo visa mitigar falhas no material como o acumulo das tensões internas durante o processo de fabricação. <br>

O Recozimento Simulado (em inglês <i>Simulated Annealing</i>) é um método otimização com natureza probabilística (ou uma heurística). O mesmo parte da ideia de uma busca local baseada na determinação de um vizinho a partir de uma ditribuição onde o valor médio ((\\micro\)) é a posição da partícula (\(x_{i}^t\)) na iteração (\t\). Normalmente a distribuição empregada para determinação do vizinho é a distribuição normal conforme Figura apresentada a seguir:

<font color="red">AQUI VAMOS COLOCAR A FOTO DE UMA DISTRIBUIÇÃO NORMAL PARA FICAR COMO EXEMPLO.</font> 

<s>Tanto seu nome quanto seu algoritmo são baseados em conceitos da termodinâmica aplicados na metalurgia, onde, para se obter um metal com uma baixa energia se segue o seguinte procedimento</s>: <font color="red">ELIMINEI ESSA PARTE POIS JÁ FALAMOS O EMBASAMENTO DO MÉTODO NO PARAGRAFO ANTERIOR. VEJA QUE ELIMINEI O PARAGRAFO EXPLICAÇÃO DO ALGORITMO E TROUXE TUDO DO TEXTO PARA UM ÚNICA SEÇÃO, SIMULANDO O QUE IRÁ OCORRER EM UM POSSÍVEL ARTIGO. <br>

VEJA QUE TBM MUDEI O NOME DAS VARIÁVEIS PRA ADEQUAR AO QUE IMPLEMENTEI. <br>

OUTRA OBSERVAÇÃO SE VOCÊ COLOCA QUE VAI MOSTRAR UM COD. PYTHON VOCÊ NÃO PODE ESCREVER EM PORTUGOL E SIM NA LINGUAGEM PYTHON SENÃO O MARKDOWN NÃO RECONHECE, VEJA COMO FICOU AGORA.
</font> 
</p>

``` python
# Algoritmo em linguagem Python 3
# Declaração de dados iniciais pelo usuário
N_ITER, I_COUNT, T_I, X_MIN, X_MAX, ALPHA, SIGMA
X = POP_INIT(X_MIN, X_MAX)
# Avalia FO e FIT das partículas
OF = OBJ(X)
FIT = FITNESS(OF)
# Definição da temperatura e iterador
TEMP = T_I
I_COUNT = 0
while (I_COUNT < N_ITER):
      # Encontrando o vizinho via distribuição pré-definida
      X_NEW = PERTURBA_VIZINHO(X, SIGMA)
      # Avalia FO e FIT das novas partículas
      OF_NEW = OBJ(X_NEW)
      FIT_NEW = FITNESS(OF_NEW)
      DELTA_E = OF_NEW - OF
      # Condição para armazenamento das variáveis
      if (DELTA_E < 0):
          PROB = 1
      elif (DELTA_E >= 0):
          PROB = exp(-DELTA_E / TEMP):
      RANDOM = rand()
      if RANDOM < PROB:
         X = X_NEW
         OF = OF_NEW
         FIT = FIT_NEW
      # Atualiza temperatura geometricamente e contador interno
      TEMP = TEMP * ALPHA
      I_COUNT = I_COUNT + 1  
# Imprimindo os valores finais
print(X, OF, FIT)
```
<ul>
<li>\( T_{i} \) (<font face="Courier New"> T_I </font>) é a Temperatura Inicial.</li>
<li>\( x_{min} \) e \( x_{min} \) (<font face="Courier New"> X_MIN </font>) e (<font face="Courier New"> X_MAX </font>) é o intervalo mínimo e máximo das variáveis de projeto.</li>
<li>\( iter \) (<font face="Courier New"> N_ITER </font>) é o número máximo de iterações (Definido pelo usuário).</li>
<li>\( x_{i}^t \) (<font face="Courier New"> X </font>) é a posição da partícula no espaço na iteração \( t \).</li>
<li>\( x_{i}^(t+1) \) (<font face="Courier New"> X_NEW </font>) é a posição da partícula no espaço na iteração \( t + 1 \).</li>
<li>\( \deltaE \) (<font face="Courier New"> DELTA_E </font>) é a variáção de energia do sistema dado por \( \deltaE = f(x_{i}^(t+1)) - f(x_{i}^t)\).</li>
<li>\( T_{i} \) (<font face="Courier New"> T_I </font>) é a Temperatura Inicial (Definido pelo usuário).</li>
<li>\( f(x_{i}^t) \) (<font face="Courier New"> OF </font>) é o valor da função objetivo no ponto \( x_{i}^t \).</li>
<li>\( f(x_{i}^(t+1)) \) (<font face="Courier New"> OF_NEW </font>) é o valor da função objetivo no ponto \( x_{i}^(t+1) \).</li>
<li>\( prob \) (<font face="Courier New"> PROB </font>) é o valor da probabilidade de aceite da solução. Para valores de \( \deltaE >0 \) utilizar  </li>
</ul> 

  •	$$ T $$ → Temperatura Inicial (Definido pelo usuário).    
  •	$$ NMI $$ → Número máximo de iterações (Definido pelo usuário).
  •	$$ P $$ → Ponto inicial aleatório.
  •	$$ NAI $$ → Número atual de iterações.
  •	$$ PN $$ → Ponto Novo.
  •	$$ PA $$ → Ponto anterior.
  •	$$ FoPN $$ → Função objetivo do ponto novo.
  •	$$ FoPA $$ → Função objetivo do ponto anterior.
  •	$$ ΔFo $$ → Diferença entre as funções objetivo.
  •	$$ Ti $$ → Temperatura na iteração.

Além dessas variáveis também existem as seguintes funções:
  •	$$ Pertuba(Ponto) $$ → Função que pertuba um ponto e retorna um novo ponto.
  •	$$ FO(Ponto) $$ → Função que retorna a função objetivo no Ponto.
  •	$$ Prob() $$ → Retorna um decimal entre 0 e 1.


### EXPLICAÇÃO DO ALGORITMO
Recozimento Simulado pode ser comparado com um outro algoritmo chamado Subida de Encosta (Hill Climbing), neste um ponto verifica seu vizinho e sempre vai para a onde há um melhor resultado, porém, apenas essa verificação faz com que o ponto sempre fique preso em um máximo local e não consiga encontrar o máximo global. Já o Recozimento Simulado tem um mecanismo probabilístico que o permite ir para lugares que dão um resultado ruim caso isso permita que ele saia de um máximo local e alcance o global.

Esse mecanismo é a temperatura. No início ela está alta, dando uma maior chance de aceitar um resultado ruim, entretanto, conforme cada iteração, essa temperatura vai diminuindo fazendo com que essa probabilidade de aceitação diminua. Logo, podemos afirmar que a probabilidade de aceitação de um resultado ruim é diretamente proporcional à temperatura.

Com isso, o problema encontrado no algoritmo da Subida de Encosta é solucionado, alguns problemas podem ser encontrados para a utilização do algoritmo como: Saber com qual temperatura iniciar, não há como saber se uma temperatura irá atender ou não o problema até testar, por isso, um dos métodos recomendados é testar vários valores diferentes até achar um com uma boa taxa e acerto.

### EXEMPLOS DE PROBLEMAS RESOLVÍVEIS
  •	Problema do Caixeiro Viajante;  
  •	Problema de Alocação;  
  •	Problema de Agendamento.
  
### MÉTODO DO ENXAME DE PARTÍCULAS

<p align="justify">
O método de Enxame de Partículas (em inglês <i>Particle Swarm Optimizatio</i>-PSO) foi proposto por James Kennedy e Russell Elberthart em 1995 [<font color="red">EULLER AQUI VOCÊ TEM QUE JÁ CITAR O ARTIGO DO PSO O ORIGINAL COLOQUE COMO URL O LINK DO ARTIGO VOU TE DAR UM EXEMPLO VEJA A FRENTE</font>] <a href="https://arxiv.org/ftp/arxiv/papers/1804/1804.05319.pdf">[1]</a>. O Enxame de Partículas ou <b>PSO</b> é um algoritmo metaheurístico baseado em inteligência de enxames que busca simular o comportamento de pássaros e cardume de peixes em busca de alimentos, cada um desses animais são chamados de partícula no método computacional. A particula possue duas propriedades principais que são: (a) a sua posição (\(x_{i}\)); e (b) sua velocidade (\(v_{i}\)), ambas representadas vetorialmente em um espaço \(n\)-dimensional [Iraj Koohi e Voicu Z. Groza <font color="red">EULLER AQUI TROCAR O NOME INTEIRO DOS CARAS POR NÚMERO....ENTÃO NOSSAS REFERÊNCIAS DEVEM SER TODAS NUMÉRICAS 1 2 3 4 5 E ASSIM POR DIANTE COMO FOI NO RELATÓRIO DE IC</font>]. Além disso o método possui uma espécie de memória que armazena um histórico das melhores posições (em relação à aptidão) no espaço \(n\)-dimensional. O histórico de armazenamento relativo a cada partícula é denominado de \( pb \) (em inglês <i>personal best</i>) e o melhor individuo do enxame também terá sua posição armazenada sendo chamado de \( gb \) (em inglês <i>global best</i>). A posição (\(x_{i}\)) e a velocidade (\(v_{i}\)) são modificadas com base nas equações (1) e (2).
</p>

<p align="justify">

\( v_{i}^{t+1} = w . v_{i}^{t} + c_1 . r_1 . (pb_{i}^{t} - x_{i}^{t}) + c_2 . r_2 . (gb_{i}^{t} - x_{i}^{t}) \) <br>  

\( x_{ij}^{t+1} = x_{ij}^{t} + v_{ij} \) <br>

Onde:<br>
</p>

<ul>
<li>\( v_{i}^{t} \) é a velocidade da partícula \(i\) na iteração \(t\).</li>
<li>\( x_{i}^{t} \) é a posição da partícula \(i\) na iteração \(t\).</li>
<li>\( x_{i}^{t+1} \) é a posição da partícula \(i\) na iteração \(t+1\).</li>
<li>\( w \) é o coeficiente de inércia. Vale 1 para versão do algoritmo original.</li>
<li>\( c_1 \) é o fator de aprendizado cognitivo.</li>
<li>\( c_2 \) é o fator de aprendizadp social.</li>
<li>\( r_1 \) e \( r_2 \) são números aleatórios em entre 0 e 1.</li>
</ul>

<p align="justify">
Os fatores de aprendizagem cognitivos e social foram criados para estebalecer um balanço (em inglês <i>trade off</i> no ato da partícula caminhar pelo espaço de busca procurando a melhor solução. Kennedy e Elberthart [1<font color="red">EULLER LEMBRAR DE COLOCAR O HYPERLINK DESSE TEXTO</font>] afirmam que esses coeficientes podem variar de 0 até 4 e quando somados (\( c_1 + c_2\)) a recomendação é que totalizem o valor 4. Além desse balanço na escolha do fator \( c_1 \) e \( c_2 \) a velocidade deve ser fixada em uma faixa, semelhante as restrições laterais (\(x_{min}\) e \(x_{max}\)) nas variáveis de projeto \(x\). Tal fato de criar imposições laterais no vetor de velocidades contribui na estabilidade do método de otimização.<br>

O funcionamento do algoritmo PSO está logo abaixo:
</p>

```python
# Algoritmo em linguagem Python 3
# Declaração de dados iniciais pelo usuário
C1, C2, W, X_MIN, X_MAX, V_MIN, V_MAX
X = POP_INIT(X_MIN, X_MAX)
V = VEL_INIT(V_MIN, V_MAX)
# Avalia FO e FIT das partículas
OF = OBJ(X)
FIT = FITNESS(OF)
for I_COUNT in range(N_ITER)
    # Busca pelos valores pb e gb
    PB = PB_AVALIACAO(X, FIT)
    GB = PB_AVALIACAO(X, FIT)
    for J_COUNT in range(N_POP)
        # Atualização velocidade
        V_NEW = VELOCITY(PB, GB, X, V) 
        # Verificação de limites de velocidade
        V_NEW = LIM_VELOCITY(V_NEW, V_MIN, V_MAX)
        # Atualização da posição no espaço
        X_NEW = POSITION(X, V_NEW)
        # Verificação da posição no espaço
        X_NEW = LIM_POSITION(X_NEW, X_MIN, X_MAX)
        OF_NEW = OBJ(X_NEW)
        FIT = FITNESS(OF_NEW)
        X = X_NEW
        OF = OF_NEW
        FIT = OF_NEW
```
<p align="justify">
  Para ter acesso ao algoritmo pode clicar no <i>link</i> <a href="https://arxiv.org/ftp/arxiv/papers/1804/1804.05319.pdf">PSO AQUI VAMOS COLOCAR O ACESSO AO NOTEBOOK JUPYTER ONLINE</a>
</p>
